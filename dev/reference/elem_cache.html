<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="selenider_element/selenider_elements objects are generally
lazy, meaning they only collect the actual element in the DOM
when absolutely necessary, and forget it immediately after. This
is to avoid situations where the DOM changes after an element
has been collected, resulting in errors and unreliable behaviour.
elem_cache() forces an element or collection of elements to be collected
and stored, making it eager rather than lazy. This is useful when you are
operating on the same element multiple times, since only collecting the
element once will improve performance. However, you must be sure that the
element will not change on the page while you are using it."><title>Force an element to be collected and stored — elem_cache • selenider</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Force an element to be collected and stored — elem_cache"><meta property="og:description" content="selenider_element/selenider_elements objects are generally
lazy, meaning they only collect the actual element in the DOM
when absolutely necessary, and forget it immediately after. This
is to avoid situations where the DOM changes after an element
has been collected, resulting in errors and unreliable behaviour.
elem_cache() forces an element or collection of elements to be collected
and stored, making it eager rather than lazy. This is useful when you are
operating on the same element multiple times, since only collecting the
element once will improve performance. However, you must be sure that the
element will not change on the page while you are using it."><meta name="robots" content="noindex"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">selenider</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.3.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item">
  <a class="nav-link" href="../articles/selenider.html">Get started</a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/unit-testing.html">Unit testing</a>
    <a class="dropdown-item" href="../articles/with-rvest.html">selenider and rvest</a>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/index.html">More articles...</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/ashbythorpe/selenider/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Force an element to be collected and stored</h1>
      <small class="dont-index">Source: <a href="https://github.com/ashbythorpe/selenider/blob/HEAD/R/cache.R" class="external-link"><code>R/cache.R</code></a></small>
      <div class="d-none name"><code>elem_cache.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>selenider_element</code>/<code>selenider_elements</code> objects are generally
<em>lazy</em>, meaning they only collect the actual element in the DOM
when absolutely necessary, and forget it immediately after. This
is to avoid situations where the DOM changes after an element
has been collected, resulting in errors and unreliable behaviour.</p>
<p><code>elem_cache()</code> forces an element or collection of elements to be collected
and stored, making it eager rather than lazy. This is useful when you are
operating on the same element multiple times, since only collecting the
element once will improve performance. However, you must be sure that the
element will not change on the page while you are using it.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">elem_cache</span><span class="op">(</span><span class="va">x</span>, timeout <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>x</dt>
<dd><p>A <code>selenider_element</code>/<code>selenider_elements</code> object.</p></dd>


<dt>timeout</dt>
<dd><p>How long to wait for the element(s) to exist while collecting
them.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>A modified version of <code>x</code>. The result of <code>elem_cache()</code> can be used
as a normal <code>selenider_element</code>/<code>selenider_elements</code> object.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>These functions do not make selenider elements <em>permanently</em> eager. Further
sub-elements will not be cached unless specified.</p>
<p>For example, consider the following code:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="fu"><a href="../reference/s.html">s</a></span><span class="op">(</span><span class="st">".class1"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/elem_ancestors.html">elem_parent</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/elem_cache.html">elem_cache</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/find_element.html">find_element</a></span><span class="op">(</span><span class="st">".class2"</span><span class="op">)</span></span></code></pre><p></p></div>
<p>In this example, the parent of the element with class ".class1" will be
cached, but the child element with class ".class2" will not.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index">
<ul><li><p><code><a href="find_element.html">find_element()</a></code> and <code><a href="find_elements.html">find_elements()</a></code> to select elements.</p></li>
<li><p><code><a href="elem_flatmap.html">element_list()</a></code>, <code><a href="find_each_element.html">find_each_element()</a></code> and <code><a href="find_each_element.html">find_all_elements()</a></code> if you
want to iterate over an element collection.</p></li>
</ul></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="va">html</span> <span class="op">&lt;-</span> <span class="st">"</span></span>
<span><span class="st">&lt;div&gt;</span></span>
<span><span class="st">&lt;p id='specifictext'&gt;&lt;/p&gt;</span></span>
<span><span class="st">&lt;button&gt;&lt;/button&gt;</span></span>
<span><span class="st">&lt;/div&gt;</span></span>
<span><span class="st">"</span></span>
<span></span>
<span><span class="va">session</span> <span class="op">&lt;-</span> <span class="fu"><a href="minimal_selenider_session.html">minimal_selenider_session</a></span><span class="op">(</span><span class="va">html</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Selecting this button may be slow, since we are using relative XPath</span></span>
<span><span class="co"># selectors.</span></span>
<span><span class="va">button</span> <span class="op">&lt;-</span> <span class="fu"><a href="s.html">s</a></span><span class="op">(</span><span class="st">"#specifictext"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="elem_ancestors.html">elem_siblings</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="elem_filter.html">elem_find</a></span><span class="op">(</span><span class="fu"><a href="has_name.html">has_name</a></span><span class="op">(</span><span class="st">"button"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># But we need to click the button 10 times!</span></span>
<span><span class="co"># Normally, this would involve fetching the button from the DOM 10 times</span></span>
<span><span class="va">click_button_10_times</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, \<span class="op">(</span><span class="va">unnused</span><span class="op">)</span> <span class="fu"><a href="elem_click.html">elem_click</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/invisible.html" class="external-link">invisible</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># But with elem_cache(), the button will only be fetched once</span></span>
<span><span class="va">cached_button</span> <span class="op">&lt;-</span> <span class="fu">elem_cache</span><span class="op">(</span><span class="va">button</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">click_button_10_times</span><span class="op">(</span><span class="va">cached_button</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># But the cached button is less reliable if the DOM is changing</span></span>
<span><span class="fu"><a href="execute_js_fn.html">execute_js_fn</a></span><span class="op">(</span><span class="st">"x =&gt; { x.outerHTML = '&lt;button&gt;&lt;/button&gt;'; }"</span>, <span class="va">button</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="elem_click.html">elem_click</a></span><span class="op">(</span><span class="va">cached_button</span>, timeout <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># But the non-cached version works</span></span>
<span><span class="fu"><a href="elem_click.html">elem_click</a></span><span class="op">(</span><span class="va">button</span><span class="op">)</span></span></code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Ashby Thorpe.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

